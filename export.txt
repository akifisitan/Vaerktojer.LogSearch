[
  {
    "path": ".editorconfig",
    "content": "# Remove the line below if you want to inherit .editorconfig settings from higher directories\r\nroot = true\r\n\r\n# C# files\r\n[*.cs]\r\n\r\n#### Core EditorConfig Options ####\r\n\r\n# Indentation and spacing\r\nindent_size = 4\r\nindent_style = space\r\ntab_width = 4\r\n\r\n# New line preferences\r\nend_of_line = crlf\r\ninsert_final_newline = false\r\n\r\n#### .NET Code Actions ####\r\n\r\n# Type members\r\ndotnet_hide_advanced_members = false\r\ndotnet_member_insertion_location = with_other_members_of_the_same_kind\r\ndotnet_property_generation_behavior = prefer_throwing_properties\r\n\r\n# Symbol search\r\ndotnet_search_reference_assemblies = true\r\n\r\n#### .NET Coding Conventions ####\r\n\r\n# Organize usings\r\ndotnet_separate_import_directive_groups = false\r\ndotnet_sort_system_directives_first = false\r\nfile_header_template = unset\r\n\r\n# this. and Me. preferences\r\ndotnet_style_qualification_for_event = false\r\ndotnet_style_qualification_for_field = false\r\ndotnet_style_qualification_for_method = false\r\ndotnet_style_qualification_for_property = false\r\n\r\n# Language keywords vs BCL types preferences\r\ndotnet_style_predefined_type_for_locals_parameters_members = true\r\ndotnet_style_predefined_type_for_member_access = true\r\n\r\n# Parentheses preferences\r\ndotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity\r\ndotnet_style_parentheses_in_other_binary_operators = always_for_clarity\r\ndotnet_style_parentheses_in_other_operators = never_if_unnecessary\r\ndotnet_style_parentheses_in_relational_binary_operators = always_for_clarity\r\n\r\n# Modifier preferences\r\ndotnet_style_require_accessibility_modifiers = for_non_interface_members\r\n\r\n# Expression-level preferences\r\ndotnet_prefer_system_hash_code = true\r\ndotnet_style_coalesce_expression = true\r\ndotnet_style_collection_initializer = true\r\ndotnet_style_explicit_tuple_names = true\r\ndotnet_style_namespace_match_folder = true\r\ndotnet_style_null_propagation = true\r\ndotnet_style_object_initializer = true\r\ndotnet_style_operator_placement_when_wrapping = beginning_of_line\r\ndotnet_style_prefer_auto_properties = true\r\ndotnet_style_prefer_collection_expression = when_types_loosely_match\r\ndotnet_style_prefer_compound_assignment = true\r\ndotnet_style_prefer_conditional_expression_over_assignment = true\r\ndotnet_style_prefer_conditional_expression_over_return = true\r\ndotnet_style_prefer_foreach_explicit_cast_in_source = when_strongly_typed\r\ndotnet_style_prefer_inferred_anonymous_type_member_names = true\r\ndotnet_style_prefer_inferred_tuple_names = true\r\ndotnet_style_prefer_is_null_check_over_reference_equality_method = true\r\ndotnet_style_prefer_simplified_boolean_expressions = true\r\ndotnet_style_prefer_simplified_interpolation = true\r\n\r\n# Field preferences\r\ndotnet_style_readonly_field = true\r\n\r\n# Parameter preferences\r\ndotnet_code_quality_unused_parameters = all\r\n\r\n# Suppression preferences\r\ndotnet_remove_unnecessary_suppression_exclusions = none\r\n\r\n# New line preferences\r\ndotnet_style_allow_multiple_blank_lines_experimental = true\r\ndotnet_style_allow_statement_immediately_after_block_experimental = true\r\n\r\n#### C# Coding Conventions ####\r\n\r\n# var preferences\r\ncsharp_style_var_elsewhere = false:silent\r\ncsharp_style_var_for_built_in_types = false:silent\r\ncsharp_style_var_when_type_is_apparent = false:silent\r\n\r\n# Expression-bodied members\r\ncsharp_style_expression_bodied_accessors = true:silent\r\ncsharp_style_expression_bodied_constructors = false:silent\r\ncsharp_style_expression_bodied_indexers = true:silent\r\ncsharp_style_expression_bodied_lambdas = true:silent\r\ncsharp_style_expression_bodied_local_functions = false:silent\r\ncsharp_style_expression_bodied_methods = false:silent\r\ncsharp_style_expression_bodied_operators = false:silent\r\ncsharp_style_expression_bodied_properties = true:silent\r\n\r\n# Pattern matching preferences\r\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\r\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\r\ncsharp_style_prefer_extended_property_pattern = true:suggestion\r\ncsharp_style_prefer_not_pattern = true:suggestion\r\ncsharp_style_prefer_pattern_matching = true:silent\r\ncsharp_style_prefer_switch_expression = true:suggestion\r\n\r\n# Null-checking preferences\r\ncsharp_style_conditional_delegate_call = true:suggestion\r\n\r\n# Modifier preferences\r\ncsharp_prefer_static_anonymous_function = true:suggestion\r\ncsharp_prefer_static_local_function = true:suggestion\r\ncsharp_preferred_modifier_order = public,private,protected,internal,file,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,required,volatile,async\r\ncsharp_style_prefer_readonly_struct = true:suggestion\r\ncsharp_style_prefer_readonly_struct_member = true:suggestion\r\n\r\n# Code-block preferences\r\ncsharp_prefer_braces = true:warning\r\ncsharp_prefer_simple_using_statement = true:suggestion\r\ncsharp_prefer_system_threading_lock = true:suggestion\r\ncsharp_style_namespace_declarations = file_scoped:error\r\ncsharp_style_prefer_method_group_conversion = true:silent\r\ncsharp_style_prefer_primary_constructors = true:silent\r\ncsharp_style_prefer_top_level_statements = true:silent\r\n\r\n# Expression-level preferences\r\ncsharp_prefer_simple_default_expression = true:suggestion\r\ncsharp_style_deconstructed_variable_declaration = true:suggestion\r\ncsharp_style_implicit_object_creation_when_type_is_apparent = true:suggestion\r\ncsharp_style_inlined_variable_declaration = true:suggestion\r\ncsharp_style_prefer_index_operator = true:suggestion\r\ncsharp_style_prefer_local_over_anonymous_function = true:suggestion\r\ncsharp_style_prefer_null_check_over_type_check = true:suggestion\r\ncsharp_style_prefer_range_operator = true:suggestion\r\ncsharp_style_prefer_tuple_swap = true:suggestion\r\ncsharp_style_prefer_unbound_generic_type_in_nameof = true:suggestion\r\ncsharp_style_prefer_utf8_string_literals = true:suggestion\r\ncsharp_style_throw_expression = true:suggestion\r\ncsharp_style_unused_value_assignment_preference = discard_variable:suggestion\r\ncsharp_style_unused_value_expression_statement_preference = discard_variable:silent\r\n\r\n# \u0027using\u0027 directive preferences\r\ncsharp_using_directive_placement = outside_namespace:warning\r\n\r\n# New line preferences\r\ncsharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental = true:silent\r\ncsharp_style_allow_blank_line_after_token_in_arrow_expression_clause_experimental = true:silent\r\ncsharp_style_allow_blank_line_after_token_in_conditional_expression_experimental = true:silent\r\ncsharp_style_allow_blank_lines_between_consecutive_braces_experimental = true:silent\r\ncsharp_style_allow_embedded_statements_on_same_line_experimental = true:silent\r\n\r\n#### C# Formatting Rules ####\r\n\r\n# New line preferences\r\ncsharp_new_line_before_catch = true\r\ncsharp_new_line_before_else = true\r\ncsharp_new_line_before_finally = true\r\ncsharp_new_line_before_members_in_anonymous_types = true\r\ncsharp_new_line_before_members_in_object_initializers = true\r\ncsharp_new_line_before_open_brace = all\r\ncsharp_new_line_between_query_expression_clauses = true\r\n\r\n# Indentation preferences\r\ncsharp_indent_block_contents = true\r\ncsharp_indent_braces = false\r\ncsharp_indent_case_contents = true\r\ncsharp_indent_case_contents_when_block = true\r\ncsharp_indent_labels = one_less_than_current\r\ncsharp_indent_switch_labels = true\r\n\r\n# Space preferences\r\ncsharp_space_after_cast = false\r\ncsharp_space_after_colon_in_inheritance_clause = true\r\ncsharp_space_after_comma = true\r\ncsharp_space_after_dot = false\r\ncsharp_space_after_keywords_in_control_flow_statements = true\r\ncsharp_space_after_semicolon_in_for_statement = true\r\ncsharp_space_around_binary_operators = before_and_after\r\ncsharp_space_around_declaration_statements = false\r\ncsharp_space_before_colon_in_inheritance_clause = true\r\ncsharp_space_before_comma = false\r\ncsharp_space_before_dot = false\r\ncsharp_space_before_open_square_brackets = false\r\ncsharp_space_before_semicolon_in_for_statement = false\r\ncsharp_space_between_empty_square_brackets = false\r\ncsharp_space_between_method_call_empty_parameter_list_parentheses = false\r\ncsharp_space_between_method_call_name_and_opening_parenthesis = false\r\ncsharp_space_between_method_call_parameter_list_parentheses = false\r\ncsharp_space_between_method_declaration_empty_parameter_list_parentheses = false\r\ncsharp_space_between_method_declaration_name_and_open_parenthesis = false\r\ncsharp_space_between_method_declaration_parameter_list_parentheses = false\r\ncsharp_space_between_parentheses = false\r\ncsharp_space_between_square_brackets = false\r\n\r\n# Wrapping preferences\r\ncsharp_preserve_single_line_blocks = true\r\ncsharp_preserve_single_line_statements = true\r\n\r\n#### Naming styles ####\r\n\r\n# Naming rules\r\n\r\ndotnet_naming_rule.interface_should_be_begins_with_i.severity = error\r\ndotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface\r\ndotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i\r\n\r\ndotnet_naming_rule.types_should_be_pascal_case.severity = warning\r\ndotnet_naming_rule.types_should_be_pascal_case.symbols = types\r\ndotnet_naming_rule.types_should_be_pascal_case.style = pascal_case\r\n\r\ndotnet_naming_rule.non_field_members_should_be_pascal_case.severity = warning\r\ndotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members\r\ndotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case\r\n\r\n# Symbol specifications\r\n\r\ndotnet_naming_symbols.interface.applicable_kinds = interface\r\ndotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected\r\ndotnet_naming_symbols.interface.required_modifiers = \r\n\r\ndotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum\r\ndotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected\r\ndotnet_naming_symbols.types.required_modifiers = \r\n\r\ndotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method\r\ndotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected\r\ndotnet_naming_symbols.non_field_members.required_modifiers = \r\n\r\n# Naming styles\r\n\r\ndotnet_naming_style.pascal_case.required_prefix = \r\ndotnet_naming_style.pascal_case.required_suffix = \r\ndotnet_naming_style.pascal_case.word_separator = \r\ndotnet_naming_style.pascal_case.capitalization = pascal_case\r\n\r\ndotnet_naming_style.begins_with_i.required_prefix = I\r\ndotnet_naming_style.begins_with_i.required_suffix = \r\ndotnet_naming_style.begins_with_i.word_separator = \r\ndotnet_naming_style.begins_with_i.capitalization = pascal_case\r\ncsharp_style_prefer_implicitly_typed_lambda_expression = true:suggestion\r\ndotnet_diagnostic.CA1309.severity = suggestion\r\ndotnet_diagnostic.CA2016.severity = warning\r\n\r\n[*.{cs,vb}]\r\ndotnet_style_operator_placement_when_wrapping = beginning_of_line\r\ntab_width = 4\r\nindent_size = 4\r\nend_of_line = crlf\r\ndotnet_style_coalesce_expression = true:suggestion\r\ndotnet_style_null_propagation = true:suggestion\r\ndotnet_style_prefer_is_null_check_over_reference_equality_method = true:warning\r\ndotnet_style_prefer_auto_properties = true:warning\r\ndotnet_style_object_initializer = true:suggestion\r\ndotnet_style_collection_initializer = true:suggestion\r\ndotnet_style_prefer_simplified_boolean_expressions = true:suggestion\r\ndotnet_style_prefer_conditional_expression_over_assignment = true:silent\r\ndotnet_style_prefer_conditional_expression_over_return = true:silent\r\ndotnet_style_explicit_tuple_names = true:suggestion\r\ndotnet_style_prefer_inferred_tuple_names = true:suggestion\r\ndotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion\r\ndotnet_style_prefer_compound_assignment = true:suggestion\r\ndotnet_style_prefer_simplified_interpolation = true:suggestion\r\ndotnet_style_prefer_collection_expression = when_types_loosely_match:suggestion\r\ndotnet_style_namespace_match_folder = true:error\r\ndotnet_style_readonly_field = true:warning\r\ndotnet_style_predefined_type_for_member_access = true:warning\r\ndotnet_style_predefined_type_for_locals_parameters_members = true:warning\r\ndotnet_style_require_accessibility_modifiers = for_non_interface_members:silent\r\ndotnet_style_allow_multiple_blank_lines_experimental = true:silent\r\ndotnet_style_allow_statement_immediately_after_block_experimental = true:silent\r\ndotnet_code_quality_unused_parameters = all:suggestion\r\ndotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:silent\r\ndotnet_style_parentheses_in_other_binary_operators = always_for_clarity:silent\r\ndotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:silent\r\ndotnet_style_parentheses_in_other_operators = never_if_unnecessary:silent\r\ndotnet_style_qualification_for_field = false:silent\r\ndotnet_style_qualification_for_property = false:silent\r\ndotnet_style_qualification_for_method = false:silent\r\ndotnet_style_qualification_for_event = false:silent\r\ndotnet_diagnostic.CA1068.severity = warning\r\ndotnet_diagnostic.CA1069.severity = error\r\ndotnet_diagnostic.CA1310.severity = warning\r\ndotnet_diagnostic.CA1501.severity = error\r\ndotnet_diagnostic.CA1852.severity = warning\r\n[*.vb]\r\ndotnet_diagnostic.CA1047.severity = warning"
  },
  {
    "path": "Vaerktojer.LogSearch.sln",
    "content": "\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio Version 17\r\nVisualStudioVersion = 17.14.36408.4\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Vaerktojer.LogSearch.ConsoleApp\u0022, \u0022Vaerktojer.LogSearch.ConsoleApp\\Vaerktojer.LogSearch.ConsoleApp.csproj\u0022, \u0022{C97EAE6D-17C9-488C-99C7-E2AACD8BE240}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Vaerktojer.LogSearch.Benchmarks\u0022, \u0022Vaerktojer.LogSearch.Benchmarks\\Vaerktojer.LogSearch.Benchmarks.csproj\u0022, \u0022{5E4D187E-E9F9-42FF-BCCA-ECEBADE96C53}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Vaerktojer.LogSearch.Lib\u0022, \u0022Vaerktojer.LogSearch.Lib\\Vaerktojer.LogSearch.Lib.csproj\u0022, \u0022{4E458B54-2447-44FA-A068-1886B03EA54C}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Vaerktojer.LogSearch.TestConsoleApp\u0022, \u0022Vaerktojer.LogSearch.TestConsoleApp\\Vaerktojer.LogSearch.TestConsoleApp.csproj\u0022, \u0022{1619E15B-C25E-4B1F-8851-8A65530B3D62}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Vaerktojer.Prompt\u0022, \u0022..\\Vaerktojer.Prompt\\Vaerktojer.Prompt\\Vaerktojer.Prompt.csproj\u0022, \u0022{DF0DF98C-DABC-4C31-3E2B-FB314B4A6AB9}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Vaerktojer.Logging.File\u0022, \u0022Vaerktojer.Logging.File\\Vaerktojer.Logging.File.csproj\u0022, \u0022{8551A278-81A0-47B9-A580-DC68E8F0D7B0}\u0022\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{C97EAE6D-17C9-488C-99C7-E2AACD8BE240}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{C97EAE6D-17C9-488C-99C7-E2AACD8BE240}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{C97EAE6D-17C9-488C-99C7-E2AACD8BE240}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{C97EAE6D-17C9-488C-99C7-E2AACD8BE240}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{5E4D187E-E9F9-42FF-BCCA-ECEBADE96C53}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{5E4D187E-E9F9-42FF-BCCA-ECEBADE96C53}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{5E4D187E-E9F9-42FF-BCCA-ECEBADE96C53}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{5E4D187E-E9F9-42FF-BCCA-ECEBADE96C53}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{4E458B54-2447-44FA-A068-1886B03EA54C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{4E458B54-2447-44FA-A068-1886B03EA54C}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{4E458B54-2447-44FA-A068-1886B03EA54C}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{4E458B54-2447-44FA-A068-1886B03EA54C}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{1619E15B-C25E-4B1F-8851-8A65530B3D62}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{1619E15B-C25E-4B1F-8851-8A65530B3D62}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{1619E15B-C25E-4B1F-8851-8A65530B3D62}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{1619E15B-C25E-4B1F-8851-8A65530B3D62}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{DF0DF98C-DABC-4C31-3E2B-FB314B4A6AB9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{DF0DF98C-DABC-4C31-3E2B-FB314B4A6AB9}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{DF0DF98C-DABC-4C31-3E2B-FB314B4A6AB9}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{DF0DF98C-DABC-4C31-3E2B-FB314B4A6AB9}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{8551A278-81A0-47B9-A580-DC68E8F0D7B0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{8551A278-81A0-47B9-A580-DC68E8F0D7B0}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{8551A278-81A0-47B9-A580-DC68E8F0D7B0}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{8551A278-81A0-47B9-A580-DC68E8F0D7B0}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {A5DBBC63-47B0-4B25-89D0-A820A6DFA99A}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.TestConsoleApp\\Program.cs",
    "content": "using System.Text;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing Bogus;\r\n\r\nnamespace Vaerktojer.LogSearch.TestConsoleApp;\r\n\r\ninternal sealed class Program\r\n{\r\n    private static readonly string[] Services =\r\n    [\r\n        \u0022trade-exec\u0022,\r\n        \u0022risk-engine\u0022,\r\n        \u0022payments\u0022,\r\n        \u0022market-data\u0022,\r\n        \u0022auth\u0022,\r\n        \u0022reporting\u0022,\r\n        \u0022gateway\u0022,\r\n    ];\r\n    private static readonly string[] Components =\r\n    [\r\n        \u0022OrderService\u0022,\r\n        \u0022RiskChecker\u0022,\r\n        \u0022SettlementProcessor\u0022,\r\n        \u0022QuoteStream\u0022,\r\n        \u0022AuthController\u0022,\r\n        \u0022ReportBuilder\u0022,\r\n        \u0022HttpClient\u0022,\r\n        \u0022SqlClient\u0022,\r\n        \u0022KafkaConsumer\u0022,\r\n    ];\r\n    private static readonly string[] Regions =\r\n    [\r\n        \u0022us-east-1\u0022,\r\n        \u0022eu-west-1\u0022,\r\n        \u0022ap-southeast-1\u0022,\r\n        \u0022us-west-2\u0022,\r\n        \u0022eu-central-1\u0022,\r\n    ];\r\n    private static readonly string[] Envs = [\u0022prod\u0022, \u0022staging\u0022];\r\n    private static readonly string[] Symbols =\r\n    [\r\n        \u0022AAPL\u0022,\r\n        \u0022MSFT\u0022,\r\n        \u0022GOOGL\u0022,\r\n        \u0022AMZN\u0022,\r\n        \u0022TSLA\u0022,\r\n        \u0022SPY\u0022,\r\n        \u0022ESZ4\u0022,\r\n        \u0022EURUSD\u0022,\r\n        \u0022BTCUSD\u0022,\r\n        \u0022ETHUSD\u0022,\r\n        \u0022XAUUSD\u0022,\r\n        \u0022NFLX\u0022,\r\n        \u0022NVDA\u0022,\r\n        \u0022META\u0022,\r\n    ];\r\n    private static readonly string[] Currencies = [\u0022USD\u0022, \u0022EUR\u0022, \u0022GBP\u0022, \u0022JPY\u0022];\r\n    private static readonly string[] Levels = [\u0022TRACE\u0022, \u0022DEBUG\u0022, \u0022INFO\u0022, \u0022WARN\u0022, \u0022ERROR\u0022];\r\n    private static readonly JsonSerializerOptions JsonOpts = new()\r\n    {\r\n        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,\r\n        WriteIndented = false,\r\n    };\r\n\r\n    private static readonly Encoding Utf8NoBom = new UTF8Encoding(\r\n        encoderShouldEmitUTF8Identifier: false\r\n    );\r\n\r\n    private static int Main(string[] args)\r\n    {\r\n        var opts = ParseArgs(args);\r\n\r\n        string outputPath = opts.Get(\u0022--output\u0022, \u0022-o\u0022) ?? \u0022finance.log\u0022;\r\n        int? targetLines = TryParseInt(opts.Get(\u0022--lines\u0022, \u0022-n\u0022));\r\n        long? targetBytes = TryParseSize(opts.Get(\u0022--size\u0022, \u0022-s\u0022));\r\n        int seed = TryParseInt(opts.Get(\u0022--seed\u0022)) ?? Random.Shared.Next();\r\n\r\n        if (targetLines is null \u0026\u0026 targetBytes is null)\r\n        {\r\n            targetLines = 100_000; // sensible default\r\n        }\r\n\r\n        Console.WriteLine($\u0022Generating logs -\u003E {outputPath}\u0022);\r\n        Console.WriteLine($\u0022Seed: {seed}\u0022);\r\n        Console.WriteLine(\r\n            targetLines is not null\r\n                ? $\u0022Target lines: {targetLines}\u0022\r\n                : $\u0022Target size: {FormatSize(targetBytes!.Value)}\u0022\r\n        );\r\n        Console.WriteLine();\r\n\r\n        Directory.CreateDirectory(Path.GetDirectoryName(Path.GetFullPath(outputPath)) ?? \u0022.\u0022);\r\n\r\n        var rnd = new Random(seed);\r\n        Randomizer.Seed = rnd;\r\n        var faker = new Faker(\u0022en\u0022);\r\n\r\n        // Use a consistent newline for predictable size accounting\r\n        using var fs = new FileStream(\r\n            outputPath,\r\n            FileMode.Create,\r\n            FileAccess.Write,\r\n            FileShare.Read,\r\n            bufferSize: 1 \u003C\u003C 20\r\n        );\r\n        using var sw = new StreamWriter(fs, Utf8NoBom, bufferSize: 1 \u003C\u003C 20);\r\n        sw.NewLine = \u0022\\n\u0022;\r\n        int newlineBytes = Utf8NoBom.GetByteCount(sw.NewLine);\r\n\r\n        long writtenBytes = 0;\r\n        long writtenLines = 0;\r\n\r\n        var start = DateTimeOffset.UtcNow.AddMinutes(-faker.Random.Int(1, 120));\r\n        var timestamp = start;\r\n\r\n        var levelChooser = WeightedChooser(\r\n            new[]\r\n            {\r\n                (\u0022TRACE\u0022, 0.05),\r\n                (\u0022DEBUG\u0022, 0.10),\r\n                (\u0022INFO\u0022, 0.75),\r\n                (\u0022WARN\u0022, 0.07),\r\n                (\u0022ERROR\u0022, 0.03),\r\n            },\r\n            rnd\r\n        );\r\n\r\n        var eventChooser = WeightedChooser(\r\n            new[]\r\n            {\r\n                (\u0022order_placed\u0022, 0.18),\r\n                (\u0022order_filled\u0022, 0.14),\r\n                (\u0022order_rejected\u0022, 0.02),\r\n                (\u0022transfer_posted\u0022, 0.06),\r\n                (\u0022balance_update\u0022, 0.06),\r\n                (\u0022risk_limit_breached\u0022, 0.01),\r\n                (\u0022login_success\u0022, 0.10),\r\n                (\u0022login_failed\u0022, 0.01),\r\n                (\u0022quote\u0022, 0.16),\r\n                (\u0022price_tick\u0022, 0.12),\r\n                (\u0022report_generated\u0022, 0.04),\r\n                (\u0022heartbeat\u0022, 0.10),\r\n            },\r\n            rnd\r\n        );\r\n\r\n        var utf8 = Utf8NoBom;\r\n\r\n        var swStopReason = \u0022completed\u0022;\r\n\r\n        try\r\n        {\r\n            Console.CancelKeyPress \u002B= (s, e) =\u003E\r\n            {\r\n                e.Cancel = true;\r\n                swStopReason = \u0022cancelled\u0022;\r\n            };\r\n\r\n            while (\r\n                (targetLines is null || writtenLines \u003C targetLines.Value)\r\n                \u0026\u0026 (targetBytes is null || writtenBytes \u003C targetBytes.Value)\r\n            )\r\n            {\r\n                if (swStopReason == \u0022cancelled\u0022)\r\n                    break;\r\n\r\n                timestamp = timestamp.AddMilliseconds(faker.Random.Int(0, 25));\r\n\r\n                string level = levelChooser();\r\n                string evt = eventChooser();\r\n\r\n                var entry = GenerateLogEntry(faker, rnd, timestamp, level, evt);\r\n\r\n                string json = JsonSerializer.Serialize(entry, JsonOpts);\r\n                sw.WriteLine(json);\r\n\r\n                writtenLines\u002B\u002B;\r\n                writtenBytes \u002B= utf8.GetByteCount(json) \u002B newlineBytes;\r\n            }\r\n        }\r\n        finally\r\n        {\r\n            sw.Flush();\r\n            fs.Flush(true);\r\n        }\r\n\r\n        Console.WriteLine($\u0022Done ({swStopReason}).\u0022);\r\n        Console.WriteLine($\u0022Lines written: {writtenLines:N0}\u0022);\r\n        Console.WriteLine($\u0022Bytes written: {writtenBytes:N0} ({FormatSize(writtenBytes)})\u0022);\r\n        return 0;\r\n    }\r\n\r\n    private static LogEntry GenerateLogEntry(\r\n        Faker faker,\r\n        Random rnd,\r\n        DateTimeOffset ts,\r\n        string level,\r\n        string evt\r\n    )\r\n    {\r\n        string service = Pick(Services, rnd);\r\n        string region = Pick(Regions, rnd);\r\n        string env = Pick(Envs, rnd);\r\n        string component = Pick(Components, rnd);\r\n\r\n        string host = $\u0022{service}-{region}-{faker.Random.Int(1, 4000):D4}\u0022;\r\n        string thread = $\u0022pool-{faker.Random.Int(1, 6)}-thread-{faker.Random.Int(1, 64)}\u0022;\r\n        string traceId = faker.Random.AlphaNumeric(16).ToLowerInvariant();\r\n        string spanId = faker.Random.AlphaNumeric(8).ToLowerInvariant();\r\n        string txnId = faker.Random.Uuid().ToString();\r\n\r\n        string accountId = $\u0022ACC-{faker.Random.Int(100000, 999999)}\u0022;\r\n        string userId = $\u0022user{faker.Random.Int(10000, 99999)}\u0022;\r\n        string currency = Pick(Currencies, rnd);\r\n        string symbol = Pick(Symbols, rnd);\r\n        string side = rnd.NextDouble() \u003C 0.5 ? \u0022BUY\u0022 : \u0022SELL\u0022;\r\n        decimal qty = Math.Round(faker.Random.Decimal(1, 10_000), 4);\r\n        var price = GeneratePriceForSymbol(symbol, faker);\r\n        decimal amount = Math.Round(qty * price, 2);\r\n\r\n        int latency = faker.Random.Int(1, 1500);\r\n        string ip = faker.Internet.Ip();\r\n        string sessionId = faker.Random.Hash(16);\r\n\r\n        // event-specific fields and message\r\n        string message;\r\n        int? httpStatus = null;\r\n        string? errorType = null;\r\n        string? errorMessage = null;\r\n\r\n        switch (evt)\r\n        {\r\n            case \u0022order_placed\u0022:\r\n                message = $\u0022Placed {side} {qty} {symbol} @ {price} {currency} account={accountId}\u0022;\r\n                break;\r\n            case \u0022order_filled\u0022:\r\n                decimal fillQty = Math.Round(\r\n                    qty * Math.Clamp((decimal)(0.5 \u002B rnd.NextDouble() / 2.0), 0.50m, 1.00m),\r\n                    4\r\n                );\r\n                message = $\u0022Filled {fillQty}/{qty} {symbol} @ {price} {currency} txn={txnId}\u0022;\r\n                break;\r\n            case \u0022order_rejected\u0022:\r\n                errorType = \u0022OrderValidationException\u0022;\r\n                errorMessage =\r\n                    rnd.NextDouble() \u003C 0.5\r\n                        ? \u0022Insufficient buying power\u0022\r\n                        : \u0022Price out of bounds vs risk limits\u0022;\r\n                message = $\u0022Order rejected: {errorMessage}\u0022;\r\n                level = \u0022WARN\u0022;\r\n                break;\r\n            case \u0022transfer_posted\u0022:\r\n                string destAcc = $\u0022ACC-{faker.Random.Int(100000, 999999)}\u0022;\r\n                message =\r\n                    $\u0022Transfer posted {amount} {currency} from {accountId} to {destAcc} txn={txnId}\u0022;\r\n                break;\r\n            case \u0022balance_update\u0022:\r\n                decimal newBal = Math.Round(faker.Random.Decimal(500, 5_000_000), 2);\r\n                message = $\u0022Balance update {accountId} {currency} -\u003E {newBal}\u0022;\r\n                break;\r\n            case \u0022risk_limit_breached\u0022:\r\n                errorType = \u0022RiskLimitBreach\u0022;\r\n                errorMessage = $\u0022Max position notional exceeded for {symbol}\u0022;\r\n                message = $\u0022Risk check failed: {errorMessage}\u0022;\r\n                level = \u0022ERROR\u0022;\r\n                break;\r\n            case \u0022login_success\u0022:\r\n                httpStatus = 200;\r\n                message = $\u0022Login success user={userId} ip={ip} session={sessionId}\u0022;\r\n                break;\r\n            case \u0022login_failed\u0022:\r\n                httpStatus = 401;\r\n                level = \u0022WARN\u0022;\r\n                message = $\u0022Login failed user={userId} ip={ip} reason=invalid_credentials\u0022;\r\n                break;\r\n            case \u0022quote\u0022:\r\n                decimal bid = Math.Round(price - (decimal)(faker.Random.Double(0.01, 0.05)), 4);\r\n                decimal ask = Math.Round(price \u002B (decimal)(faker.Random.Double(0.01, 0.05)), 4);\r\n                message = $\u0022Quote {symbol} bid={bid} ask={ask} spread={Math.Round(ask - bid, 4)}\u0022;\r\n                break;\r\n            case \u0022price_tick\u0022:\r\n                message = $\u0022Tick {symbol} px={price}\u0022;\r\n                break;\r\n            case \u0022report_generated\u0022:\r\n                httpStatus = 200;\r\n                message =\r\n                    $\u0022Report generated type=PnL period=1D rows={faker.Random.Int(100, 50000)}\u0022;\r\n                break;\r\n            case \u0022heartbeat\u0022:\r\n                message = $\u0022Heartbeat\u0022;\r\n                break;\r\n            default:\r\n                message = $\u0022Event {evt}\u0022;\r\n                break;\r\n        }\r\n\r\n        // Occasionally add an ERROR around IO/DB/Kafka\r\n        if (level == \u0022ERROR\u0022 \u0026\u0026 errorType is null)\r\n        {\r\n            var errChoice = rnd.Next(3);\r\n            if (errChoice == 0)\r\n            {\r\n                errorType = \u0022SqlTimeoutException\u0022;\r\n                errorMessage = \u0022SQL timeout after 30s\u0022;\r\n                httpStatus = 504;\r\n            }\r\n            if (errChoice == 1)\r\n            {\r\n                errorType = \u0022KafkaCommitException\u0022;\r\n                errorMessage = \u0022Failed to commit offset\u0022;\r\n            }\r\n            if (errChoice == 2)\r\n            {\r\n                errorType = \u0022HttpRequestException\u0022;\r\n                errorMessage = \u0022Connection reset by peer\u0022;\r\n                httpStatus = 502;\r\n            }\r\n            message = $\u0022{message} ({errorType}: {errorMessage})\u0022;\r\n        }\r\n\r\n        return new LogEntry\r\n        {\r\n            ts = ts.ToString(\u0022o\u0022),\r\n            level = level,\r\n            env = env,\r\n            region = region,\r\n            service = service,\r\n            component = component,\r\n            host = host,\r\n            thread = thread,\r\n            traceId = traceId,\r\n            spanId = spanId,\r\n            @event = evt,\r\n            message = message,\r\n            transactionId = txnId,\r\n            accountId = accountId,\r\n            userId = userId,\r\n            symbol = symbol,\r\n            side = side,\r\n            quantity = evt is \u0022order_placed\u0022 or \u0022order_filled\u0022 ? qty : null,\r\n            price = evt is \u0022order_placed\u0022 or \u0022order_filled\u0022 or \u0022price_tick\u0022 ? price : null,\r\n            amount = evt is \u0022transfer_posted\u0022 ? amount : null,\r\n            currency = currency,\r\n            ip = evt.StartsWith(\u0022login\u0022) ? ip : null,\r\n            sessionId = evt.StartsWith(\u0022login\u0022) ? sessionId : null,\r\n            httpStatus = httpStatus,\r\n            latencyMs = latency,\r\n            errorType = errorType,\r\n            errorMessage = errorMessage,\r\n            // a few extra operational fields useful for search benchmarks\r\n            kafkaPartition = faker.Random.Int(0, 15),\r\n            kafkaOffset = faker.Random.Long(0, 5_000_000),\r\n            sqlRows = evt is \u0022report_generated\u0022 ? faker.Random.Int(100, 50_000) : null,\r\n        };\r\n    }\r\n\r\n    private static decimal GeneratePriceForSymbol(string symbol, Faker faker)\r\n    {\r\n        // Very rough price bands\r\n        return symbol switch\r\n        {\r\n            \u0022BTCUSD\u0022 =\u003E Math.Round(faker.Random.Decimal(20_000, 90_000), 2),\r\n            \u0022ETHUSD\u0022 =\u003E Math.Round(faker.Random.Decimal(800, 6_000), 2),\r\n            \u0022EURUSD\u0022 =\u003E Math.Round(faker.Random.Decimal(0.9m, 1.2m), 5),\r\n            \u0022XAUUSD\u0022 =\u003E Math.Round(faker.Random.Decimal(1500, 2600), 2),\r\n            \u0022SPY\u0022 =\u003E Math.Round(faker.Random.Decimal(300, 700), 2),\r\n            \u0022ESZ4\u0022 =\u003E Math.Round(faker.Random.Decimal(3000, 7000), 2),\r\n            _ =\u003E Math.Round(faker.Random.Decimal(20, 1200), 2),\r\n        };\r\n    }\r\n\r\n    private static T Pick\u003CT\u003E(IReadOnlyList\u003CT\u003E arr, Random rnd) =\u003E arr[rnd.Next(arr.Count)];\r\n\r\n    private static Func\u003Cstring\u003E WeightedChooser((string key, double weight)[] items, Random rnd)\r\n    {\r\n        double total = 0;\r\n        foreach (var it in items)\r\n            total \u002B= it.weight;\r\n        var cumulative = new double[items.Length];\r\n        double sum = 0;\r\n        for (int i = 0; i \u003C items.Length; i\u002B\u002B)\r\n        {\r\n            sum \u002B= items[i].weight / total;\r\n            cumulative[i] = sum;\r\n        }\r\n\r\n        return () =\u003E\r\n        {\r\n            double r = rnd.NextDouble();\r\n            for (int i = 0; i \u003C items.Length; i\u002B\u002B)\r\n            {\r\n                if (r \u003C= cumulative[i])\r\n                    return items[i].key;\r\n            }\r\n            return items[^1].key;\r\n        };\r\n    }\r\n\r\n    private static Dictionary\u003Cstring, string?\u003E ParseArgs(string[] args)\r\n    {\r\n        var dict = new Dictionary\u003Cstring, string?\u003E(StringComparer.OrdinalIgnoreCase);\r\n        for (int i = 0; i \u003C args.Length; i\u002B\u002B)\r\n        {\r\n            string a = args[i];\r\n            if (a.StartsWith(\u0022--\u0022) || a.StartsWith(\u0022-\u0022))\r\n            {\r\n                string? val = null;\r\n                if (i \u002B 1 \u003C args.Length \u0026\u0026 !args[i \u002B 1].StartsWith(\u0022-\u0022))\r\n                {\r\n                    val = args[\u002B\u002Bi];\r\n                }\r\n                dict[a] = val;\r\n            }\r\n        }\r\n        return dict;\r\n    }\r\n\r\n    private static int? TryParseInt(string? s) =\u003E int.TryParse(s, out var i) ? i : null;\r\n\r\n    private static long? TryParseSize(string? s)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(s))\r\n            return null;\r\n        s = s.Trim().Replace(\u0022_\u0022, \u0022\u0022).Replace(\u0022 \u0022, \u0022\u0022);\r\n        // Accept plain bytes or suffixes KB, MB, GB, TB\r\n        var numberPart = new string(s.TakeWhile(ch =\u003E char.IsDigit(ch) || ch == \u0027.\u0027).ToArray());\r\n        var unitPart = s[numberPart.Length..].ToUpperInvariant();\r\n\r\n        if (\r\n            !double.TryParse(\r\n                numberPart,\r\n                System.Globalization.NumberStyles.Float,\r\n                System.Globalization.CultureInfo.InvariantCulture,\r\n                out var value\r\n            )\r\n        )\r\n            return null;\r\n\r\n        long multiplier = 1;\r\n        unitPart = unitPart switch\r\n        {\r\n            \u0022\u0022 or \u0022B\u0022 =\u003E \u0022B\u0022,\r\n            \u0022K\u0022 or \u0022KB\u0022 =\u003E \u0022KB\u0022,\r\n            \u0022M\u0022 or \u0022MB\u0022 =\u003E \u0022MB\u0022,\r\n            \u0022G\u0022 or \u0022GB\u0022 =\u003E \u0022GB\u0022,\r\n            \u0022T\u0022 or \u0022TB\u0022 =\u003E \u0022TB\u0022,\r\n            _ =\u003E \u0022B\u0022,\r\n        };\r\n\r\n        multiplier = unitPart switch\r\n        {\r\n            \u0022B\u0022 =\u003E 1L,\r\n            \u0022KB\u0022 =\u003E 1024L,\r\n            \u0022MB\u0022 =\u003E 1024L * 1024L,\r\n            \u0022GB\u0022 =\u003E 1024L * 1024L * 1024L,\r\n            \u0022TB\u0022 =\u003E 1024L * 1024L * 1024L * 1024L,\r\n            _ =\u003E 1L,\r\n        };\r\n        var bytes = (long)(value * multiplier);\r\n        return bytes \u003C 0 ? 0 : bytes;\r\n    }\r\n\r\n    private static string FormatSize(long bytes)\r\n    {\r\n        double b = bytes;\r\n        string[] units = { \u0022B\u0022, \u0022KB\u0022, \u0022MB\u0022, \u0022GB\u0022, \u0022TB\u0022 };\r\n        int i = 0;\r\n        while (b \u003E= 1024 \u0026\u0026 i \u003C units.Length - 1)\r\n        {\r\n            b /= 1024;\r\n            i\u002B\u002B;\r\n        }\r\n        return $\u0022{b:0.##} {units[i]}\u0022;\r\n    }\r\n}\r\n\r\npublic static class Extensions\r\n{\r\n    public static string? Get(this Dictionary\u003Cstring, string?\u003E d, params string[] keys)\r\n    {\r\n        foreach (var k in keys)\r\n        {\r\n            if (d.TryGetValue(k, out var v))\r\n                return v;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\npublic sealed class LogEntry\r\n{\r\n    public string ts { get; set; } = default!;\r\n    public string level { get; set; } = default!;\r\n    public string env { get; set; } = default!;\r\n    public string region { get; set; } = default!;\r\n    public string service { get; set; } = default!;\r\n    public string component { get; set; } = default!;\r\n    public string host { get; set; } = default!;\r\n    public string thread { get; set; } = default!;\r\n    public string traceId { get; set; } = default!;\r\n    public string spanId { get; set; } = default!;\r\n    public string @event { get; set; } = default!;\r\n    public string message { get; set; } = default!;\r\n    public string transactionId { get; set; } = default!;\r\n    public string accountId { get; set; } = default!;\r\n    public string userId { get; set; } = default!;\r\n    public string symbol { get; set; } = default!;\r\n    public string side { get; set; } = default!;\r\n    public decimal? quantity { get; set; }\r\n    public decimal? price { get; set; }\r\n    public decimal? amount { get; set; }\r\n    public string currency { get; set; } = default!;\r\n    public string? ip { get; set; }\r\n    public string? sessionId { get; set; }\r\n    public int? httpStatus { get; set; }\r\n    public int? latencyMs { get; set; }\r\n    public string? errorType { get; set; }\r\n    public string? errorMessage { get; set; }\r\n\r\n    // optional operational fields\r\n    public int? kafkaPartition { get; set; }\r\n    public long? kafkaOffset { get; set; }\r\n    public int? sqlRows { get; set; }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.TestConsoleApp\\Vaerktojer.LogSearch.TestConsoleApp.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CPublishAot\u003Efalse\u003C/PublishAot\u003E\r\n    \u003CInvariantGlobalization\u003Etrue\u003C/InvariantGlobalization\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022Bogus\u0022 Version=\u002235.6.3\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.DependencyInjection\u0022 Version=\u00229.0.8\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022Vaerktojer.Prompt\u0022 Version=\u00220.0.1\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CProjectReference Include=\u0022..\\Vaerktojer.LogSearch.Lib\\Vaerktojer.LogSearch.Lib.csproj\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\AppJsonSerializerContext.cs",
    "content": "using System.Text.Json.Serialization;\r\nusing Vaerktojer.LogSearch.Lib.Data;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib;\r\n\r\n[JsonSourceGenerationOptions(\r\n    WriteIndented = true,\r\n    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,\r\n    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull\r\n)]\r\n[JsonSerializable(typeof(SearchResult))]\r\npublic partial class AppJsonSerializerContext : JsonSerializerContext { }\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\DIRegistrations.cs",
    "content": "using Microsoft.Extensions.DependencyInjection;\r\nusing Vaerktojer.LogSearch.Lib.Core;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib;\r\n\r\npublic static class DIRegistrations\r\n{\r\n    public static IServiceCollection AddLogSearchLib(this IServiceCollection services)\r\n    {\r\n        services.AddSingleton\u003CFileSearcher\u003E();\r\n        services.AddSingleton\u003CZipFileSearcher\u003E();\r\n\r\n        return services;\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Utils.cs",
    "content": "using System.Diagnostics;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib;\r\n\r\npublic static class Utils\r\n{\r\n    public static void OpenWithNpp(string path)\r\n    {\r\n        Process.Start(\r\n            new ProcessStartInfo\r\n            {\r\n                FileName = @\u0022C:\\Program Files\\Notepad\u002B\u002B\\notepad\u002B\u002B.exe\u0022,\r\n                Arguments = $\u0022\\\u0022{path}\\\u0022\u0022,\r\n                UseShellExecute = false,\r\n                CreateNoWindow = true,\r\n            }\r\n        );\r\n    }\r\n\r\n    public static bool IsZip(string path) =\u003E\r\n        Path.GetExtension(path).Equals(\u0022.zip\u0022, StringComparison.OrdinalIgnoreCase);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Vaerktojer.LogSearch.Lib.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003ELibrary\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CIsAotCompatible\u003Etrue\u003C/IsAotCompatible\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference\r\n      Include=\u0022Microsoft.Extensions.DependencyInjection.Abstractions\u0022\r\n      Version=\u00229.0.8\u0022\r\n    /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.FileSystemGlobbing\u0022 Version=\u00229.0.8\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.Logging.Abstractions\u0022 Version=\u00229.0.8\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022ZLogger\u0022 Version=\u00222.5.10\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Matchers\\RegexLineMatcher.cs",
    "content": "using System.Text.RegularExpressions;\r\nusing Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Matchers;\r\n\r\npublic readonly record struct RegexLineMatcher : ILineMatcher\r\n{\r\n    private readonly Regex _value;\r\n\r\n    public RegexLineMatcher(string pattern)\r\n    {\r\n        _value = new Regex(\r\n            pattern,\r\n            RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.NonBacktracking\r\n        );\r\n    }\r\n\r\n    public bool IsMatch(string line) =\u003E _value.IsMatch(line);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Matchers\\SpanContainsLineMatcher.cs",
    "content": "using Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Matchers;\r\n\r\npublic readonly record struct SpanContainsLineMatcher : ISpanLineMatcher\r\n{\r\n    private readonly string _value;\r\n\r\n    public SpanContainsLineMatcher(string value)\r\n    {\r\n        _value = value;\r\n    }\r\n\r\n    public bool IsMatch(ReadOnlySpan\u003Cchar\u003E line)\r\n    {\r\n        return line.Contains(_value, StringComparison.OrdinalIgnoreCase);\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Matchers\\StringContainsLineMatcher.cs",
    "content": "using Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Matchers;\r\n\r\npublic readonly record struct StringContainsLineMatcher : ILineMatcher\r\n{\r\n    private readonly string _value;\r\n\r\n    public StringContainsLineMatcher(string value)\r\n    {\r\n        _value = value;\r\n    }\r\n\r\n    public bool IsMatch(string line) =\u003E line.Contains(_value);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Filters\\LogFileEnumerationFilter.cs",
    "content": "using System.IO.Enumeration;\r\nusing Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Filters;\r\n\r\npublic readonly record struct LogFileEnumerationFilter : IFileSystemEnumerationFilter\r\n{\r\n    private readonly DateTimeOffset _startDateUtc;\r\n    private readonly DateTimeOffset _endDateUtc;\r\n\r\n    public LogFileEnumerationFilter(DateTimeOffset startDateUtc, DateTimeOffset endDateUtc)\r\n    {\r\n        _startDateUtc = startDateUtc;\r\n        _endDateUtc = endDateUtc;\r\n    }\r\n\r\n    public bool IncludeFile(ref FileSystemEntry entry) =\u003E\r\n        Path.GetExtension(entry.FileName).Equals(\u0022.log\u0022, StringComparison.OrdinalIgnoreCase)\r\n        \u0026\u0026 entry.LastWriteTimeUtc \u003C= _endDateUtc\r\n        \u0026\u0026 entry.CreationTimeUtc \u003E= _startDateUtc;\r\n\r\n    public bool ExcludeDirectory(ref FileSystemEntry entry) =\u003E false;\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Filters\\TextFileEnumerationFilter.cs",
    "content": "using System.IO.Enumeration;\r\nusing Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Filters;\r\n\r\npublic readonly record struct TextFileEnumerationFilter : IFileSystemEnumerationFilter\r\n{\r\n    public bool IncludeFile(ref FileSystemEntry entry) =\u003E\r\n        Path.GetExtension(entry.FileName).Equals(\u0022.txt\u0022, StringComparison.OrdinalIgnoreCase);\r\n\r\n    public bool ExcludeDirectory(ref FileSystemEntry entry) =\u003E false;\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Filters\\ZipArchiveEntryFilter.cs",
    "content": "using System.IO.Compression;\r\nusing Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Filters;\r\n\r\npublic readonly record struct ZipArchiveEntryFilter : IZipArchiveEntryFilter\r\n{\r\n    private readonly DateTimeOffset _startDate;\r\n\r\n    public ZipArchiveEntryFilter(DateTimeOffset startDate)\r\n    {\r\n        _startDate = startDate;\r\n    }\r\n\r\n    public bool Include(ZipArchiveEntry entry)\r\n    {\r\n        return Path.GetExtension(entry.FullName).Equals(\u0022.log\u0022, StringComparison.OrdinalIgnoreCase)\r\n            \u0026\u0026 entry.LastWriteTime \u003C _startDate;\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Filters\\ZipFileEnumerationFilter.cs",
    "content": "using System.IO.Enumeration;\r\nusing Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Filters;\r\n\r\npublic readonly record struct ZipFileEnumerationFilter : IFileSystemEnumerationFilter\r\n{\r\n    public bool IncludeFile(ref FileSystemEntry entry) =\u003E\r\n        Path.GetExtension(entry.FileName).Equals(\u0022.zip\u0022, StringComparison.OrdinalIgnoreCase);\r\n\r\n    public bool ExcludeDirectory(ref FileSystemEntry entry) =\u003E false;\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Data\\Errors.cs",
    "content": "namespace Vaerktojer.LogSearch.Lib.Data;\r\n\r\npublic sealed class NotSureError() : Exception(\u0022\u0022);\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Data\\Records.cs",
    "content": "namespace Vaerktojer.LogSearch.Lib.Data;\r\n\r\npublic sealed record SearchResult(string FilePath, int LineNumber, string LineContent);\r\n\r\npublic sealed record ZipFileSearchOptions(string? ExtractPath = null, bool StopWhenFound = true)\r\n{\r\n    public static ZipFileSearchOptions Default =\u003E new();\r\n}\r\n\r\npublic sealed record FileSearchOptions(bool StopWhenFound = true)\r\n{\r\n    public static FileSearchOptions Default =\u003E new();\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Core\\FileEnumerator.cs",
    "content": "using System.IO.Enumeration;\r\nusing Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Core;\r\n\r\npublic static class FileEnumerator\r\n{\r\n    public static IEnumerable\u003Cstring\u003E EnumerateFiles\u003CTFilter\u003E(\r\n        string rootDirectoryPath,\r\n        TFilter filter,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n        where TFilter : IFileSystemEnumerationFilter\r\n    {\r\n        var enumerationOptions = new EnumerationOptions\r\n        {\r\n            RecurseSubdirectories = true,\r\n            IgnoreInaccessible = true,\r\n            AttributesToSkip =\r\n                FileAttributes.Hidden | FileAttributes.System | FileAttributes.ReparsePoint,\r\n            ReturnSpecialDirectories = false,\r\n        };\r\n\r\n        var enumeration = new FileSystemEnumerable\u003Cstring\u003E(\r\n            directory: rootDirectoryPath,\r\n            transform: (ref FileSystemEntry entry) =\u003E entry.ToFullPath(),\r\n            options: enumerationOptions\r\n        )\r\n        {\r\n            ShouldIncludePredicate = (ref FileSystemEntry entry) =\u003E\r\n            {\r\n                cancellationToken.ThrowIfCancellationRequested();\r\n\r\n                if (entry.IsDirectory)\r\n                {\r\n                    return false;\r\n                }\r\n\r\n                return filter.IncludeFile(ref entry);\r\n            },\r\n            ShouldRecursePredicate = (ref FileSystemEntry entry) =\u003E\r\n            {\r\n                cancellationToken.ThrowIfCancellationRequested();\r\n\r\n                return !filter.ExcludeDirectory(ref entry);\r\n            },\r\n        };\r\n\r\n        foreach (var path in enumeration)\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested();\r\n            yield return path;\r\n        }\r\n    }\r\n\r\n    public static IEnumerable\u003CFileSystemInfo\u003E EnumerateFilesToFileSystemInfo\u003CTFilter\u003E(\r\n        string rootDirectoryPath,\r\n        TFilter filter,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n        where TFilter : IFileSystemEnumerationFilter\r\n    {\r\n        var enumerationOptions = new EnumerationOptions\r\n        {\r\n            RecurseSubdirectories = true,\r\n            IgnoreInaccessible = true,\r\n            AttributesToSkip =\r\n                FileAttributes.Hidden | FileAttributes.System | FileAttributes.ReparsePoint,\r\n            ReturnSpecialDirectories = false,\r\n        };\r\n\r\n        var enumeration = new FileSystemEnumerable\u003CFileSystemInfo\u003E(\r\n            directory: rootDirectoryPath,\r\n            transform: (ref FileSystemEntry entry) =\u003E entry.ToFileSystemInfo(),\r\n            options: enumerationOptions\r\n        )\r\n        {\r\n            ShouldIncludePredicate = (ref FileSystemEntry entry) =\u003E\r\n            {\r\n                cancellationToken.ThrowIfCancellationRequested();\r\n\r\n                if (entry.IsDirectory)\r\n                {\r\n                    return false;\r\n                }\r\n\r\n                return filter.IncludeFile(ref entry);\r\n            },\r\n            ShouldRecursePredicate = (ref FileSystemEntry entry) =\u003E\r\n            {\r\n                cancellationToken.ThrowIfCancellationRequested();\r\n\r\n                return !filter.ExcludeDirectory(ref entry);\r\n            },\r\n        };\r\n\r\n        foreach (var path in enumeration)\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested();\r\n            yield return path;\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Core\\FileSearcher.cs",
    "content": "using System.Runtime.CompilerServices;\r\nusing Vaerktojer.LogSearch.Lib.Abstractions;\r\nusing Vaerktojer.LogSearch.Lib.Data;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Core;\r\n\r\npublic sealed class FileSearcher\r\n{\r\n    private const int _bufferSize = 4096 * 2;\r\n\r\n    public static IEnumerable\u003CSearchResult\u003E SearchInFile\u003CTMatcher\u003E(\r\n        string filePath,\r\n        TMatcher matcher,\r\n        FileSearchOptions? options = null,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n        where TMatcher : ILineMatcher\r\n    {\r\n        options ??= FileSearchOptions.Default;\r\n\r\n        using var stream = new FileStream(\r\n            filePath,\r\n            FileMode.Open,\r\n            FileAccess.Read,\r\n            FileShare.Read,\r\n            _bufferSize,\r\n            FileOptions.SequentialScan\r\n        );\r\n\r\n        using var reader = new StreamReader(stream);\r\n\r\n        string? line;\r\n        var lineNumber = 0;\r\n\r\n        while ((line = reader.ReadLine()) != null)\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested();\r\n\r\n            lineNumber\u002B\u002B;\r\n\r\n            if (matcher.IsMatch(line))\r\n            {\r\n                yield return new(filePath, lineNumber, line);\r\n\r\n                if (options.StopWhenFound)\r\n                {\r\n                    yield break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static async IAsyncEnumerable\u003CSearchResult\u003E SearchInFileAsync\u003CTMatcher\u003E(\r\n        string filePath,\r\n        TMatcher matcher,\r\n        FileSearchOptions? options = null,\r\n        [EnumeratorCancellation] CancellationToken cancellationToken = default\r\n    )\r\n        where TMatcher : ILineMatcher\r\n    {\r\n        options ??= FileSearchOptions.Default;\r\n\r\n        await using var stream = new FileStream(\r\n            filePath,\r\n            FileMode.Open,\r\n            FileAccess.Read,\r\n            FileShare.Read,\r\n            _bufferSize,\r\n            FileOptions.Asynchronous | FileOptions.SequentialScan\r\n        );\r\n\r\n        using var reader = new StreamReader(stream);\r\n\r\n        string? line;\r\n        var lineNumber = 0;\r\n\r\n        while ((line = await reader.ReadLineAsync(cancellationToken).ConfigureAwait(false)) != null)\r\n        {\r\n            lineNumber\u002B\u002B;\r\n\r\n            if (matcher.IsMatch(line))\r\n            {\r\n                yield return new(filePath, lineNumber, line);\r\n\r\n                if (options.StopWhenFound)\r\n                {\r\n                    yield break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Core\\ZipFileSearcher.cs",
    "content": "using System.IO.Compression;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Text;\r\nusing Vaerktojer.LogSearch.Lib.Abstractions;\r\nusing Vaerktojer.LogSearch.Lib.Data;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Core;\r\n\r\npublic sealed class ZipFileSearcher\r\n{\r\n    private const int _bufferSize = 4096;\r\n\r\n    public static IEnumerable\u003CSearchResult\u003E SearchInZip\u003CTLineMatcher, TZipArchiveEntryFilter\u003E(\r\n        string zipFilePath,\r\n        TLineMatcher lineMatcher,\r\n        TZipArchiveEntryFilter zipArchiveEntryFilter,\r\n        ZipFileSearchOptions? options = null,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n        where TLineMatcher : ILineMatcher\r\n        where TZipArchiveEntryFilter : IZipArchiveEntryFilter\r\n    {\r\n        options ??= ZipFileSearchOptions.Default;\r\n\r\n        using var archive = ZipFile.OpenRead(zipFilePath);\r\n\r\n        foreach (var entry in archive.Entries)\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested();\r\n\r\n            if (!zipArchiveEntryFilter.Include(entry))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            using var stream = entry.Open();\r\n            using var reader = new StreamReader(stream);\r\n\r\n            string? line;\r\n            var lineNumber = 0;\r\n\r\n            while ((line = reader.ReadLine()) != null)\r\n            {\r\n                cancellationToken.ThrowIfCancellationRequested();\r\n\r\n                lineNumber\u002B\u002B;\r\n\r\n                if (lineMatcher.IsMatch(line))\r\n                {\r\n                    yield return new(Path.Combine(zipFilePath, entry.FullName), lineNumber, line);\r\n\r\n                    if (options.StopWhenFound)\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static async IAsyncEnumerable\u003CSearchResult\u003E SearchInZipAsync\u003C\r\n        TLineMatcher,\r\n        TZipArchiveEntryFilter\r\n    \u003E(\r\n        string zipFilePath,\r\n        TLineMatcher lineMatcher,\r\n        TZipArchiveEntryFilter zipArchiveEntryFilter,\r\n        ZipFileSearchOptions? options = null,\r\n        [EnumeratorCancellation] CancellationToken cancellationToken = default\r\n    )\r\n        where TLineMatcher : ILineMatcher\r\n        where TZipArchiveEntryFilter : IZipArchiveEntryFilter\r\n    {\r\n        options ??= ZipFileSearchOptions.Default;\r\n\r\n        await using var zipFs = new FileStream(\r\n            zipFilePath,\r\n            FileMode.Open,\r\n            FileAccess.Read,\r\n            FileShare.Read,\r\n            _bufferSize,\r\n            FileOptions.Asynchronous | FileOptions.SequentialScan\r\n        );\r\n\r\n        cancellationToken.ThrowIfCancellationRequested();\r\n\r\n        using var archive = new ZipArchive(\r\n            zipFs,\r\n            ZipArchiveMode.Read,\r\n            leaveOpen: false,\r\n            Encoding.UTF8\r\n        );\r\n\r\n        foreach (var entry in archive.Entries)\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested();\r\n\r\n            if (!zipArchiveEntryFilter.Include(entry))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            using var stream = entry.Open();\r\n            using var reader = new StreamReader(stream);\r\n\r\n            string? line;\r\n            var lineNumber = 0;\r\n\r\n            while (\r\n                (line = await reader.ReadLineAsync(cancellationToken).ConfigureAwait(false)) != null\r\n            )\r\n            {\r\n                lineNumber\u002B\u002B;\r\n\r\n                if (lineMatcher.IsMatch(line))\r\n                {\r\n                    yield return new(Path.Combine(zipFilePath, entry.FullName), lineNumber, line);\r\n\r\n                    if (options.StopWhenFound)\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Abstractions\\IFileSystemEnumerationFilter.cs",
    "content": "using System.IO.Enumeration;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\npublic interface IFileSystemEnumerationFilter\r\n{\r\n    bool IncludeFile(ref FileSystemEntry entry);\r\n    bool ExcludeDirectory(ref FileSystemEntry entry);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Abstractions\\ILineMatcher.cs",
    "content": "namespace Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\npublic interface ILineMatcher\r\n{\r\n    bool IsMatch(string line);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Abstractions\\ISpanLineMatcher.cs",
    "content": "namespace Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\npublic interface ISpanLineMatcher\r\n{\r\n    bool IsMatch(ReadOnlySpan\u003Cchar\u003E line);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Lib\\Abstractions\\IZipArchiveEntryFilter.cs",
    "content": "using System.IO.Compression;\r\n\r\nnamespace Vaerktojer.LogSearch.Lib.Abstractions;\r\n\r\npublic interface IZipArchiveEntryFilter\r\n{\r\n    bool Include(ZipArchiveEntry entry);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Data\\Errors.cs",
    "content": "namespace Vaerktojer.LogSearch.Data;\r\n\r\npublic sealed class NotSureError() : Exception(\u0022Idk\u0022);\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Data\\Records.cs",
    "content": "namespace Vaerktojer.LogSearch.Data;\r\n\r\npublic sealed record SearchResult(string FilePath, int LineNumber, string LineContent);\r\n\r\npublic sealed record ZipFileSearchOptions(string? ExtractPath = null, bool StopWhenFound = true)\r\n{\r\n    public static ZipFileSearchOptions Default =\u003E new();\r\n}\r\n\r\npublic sealed record FileSearchOptions(bool StopWhenFound = true)\r\n{\r\n    public static FileSearchOptions Default =\u003E new();\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Data\\Vaerktojer.LogSearch.Data.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003ELibrary\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet8.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CIsAotCompatible\u003Etrue\u003C/IsAotCompatible\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference\r\n      Include=\u0022Microsoft.Extensions.DependencyInjection.Abstractions\u0022\r\n      Version=\u00229.0.8\u0022\r\n    /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.ConsoleApp\\App.cs",
    "content": "using System.Threading.Channels;\r\nusing Microsoft.Extensions.Logging;\r\nusing Vaerktojer.LogSearch.Lib.Core;\r\nusing Vaerktojer.LogSearch.Lib.Data;\r\nusing Vaerktojer.LogSearch.Lib.Filters;\r\nusing Vaerktojer.LogSearch.Lib.Matchers;\r\nusing ZLogger;\r\n\r\nnamespace Vaerktojer.LogSearch.ConsoleApp;\r\n\r\ninternal class App(ILogger\u003CApp\u003E logger)\r\n{\r\n    private const string _basePath = @\u0022C:\\Users\\user\u0022;\r\n    private const string _searchPattern = \u0022f47de3ba-c88c-6c50-cae7-4b72b2e9346b\u0022;\r\n    private readonly DateTimeOffset _startTime = DateTimeOffset.Now;\r\n    private readonly DateTimeOffset _endTime = DateTimeOffset.Now;\r\n    private const int _maxDegreeOfParallelism = 4;\r\n\r\n    public async Task Run()\r\n    {\r\n        var r = new Random();\r\n\r\n        while (true)\r\n        {\r\n            var randomValue = r.Next(100);\r\n\r\n            logger.ZLogInformation($\u0022Hello World from my method. Random value: {randomValue}\u0022);\r\n\r\n            if (randomValue == 1)\r\n            {\r\n                break;\r\n            }\r\n\r\n            await Task.Delay(500);\r\n        }\r\n\r\n        throw new Exception(\u0022wowzer\u0022);\r\n\r\n        using var cts = new CancellationTokenSource();\r\n        var cancellationToken = cts.Token;\r\n\r\n        var fileEnumerator = FileEnumerator\r\n            .EnumerateFiles(\r\n                _basePath,\r\n                new TextFileEnumerationFilter(),\r\n                cancellationToken: cancellationToken\r\n            )\r\n            .ToList();\r\n\r\n        var v = Prompt.Prompt.Select(\r\n            \u0022Select file\u0022,\r\n            fileEnumerator,\r\n            pageSize: 20,\r\n            textSelector: x =\u003E x[..Math.Min(50, x.Length)]\r\n        );\r\n    }\r\n\r\n    private async Task Idk()\r\n    {\r\n        using var cts = new CancellationTokenSource();\r\n        var cancellationToken = cts.Token;\r\n\r\n        var fileEnumerator = FileEnumerator.EnumerateFiles(\r\n            _basePath,\r\n            new ZipFileEnumerationFilter(),\r\n            cancellationToken: cancellationToken\r\n        );\r\n\r\n        var options = new ZipFileSearchOptions(StopWhenFound: false);\r\n        var lineMatcher = new StringContainsLineMatcher(_searchPattern);\r\n        var fileMatcher = new ZipArchiveEntryFilter(_endTime);\r\n\r\n        var capacity = Math.Max(_maxDegreeOfParallelism * 2, 1);\r\n        var channel = Channel.CreateBounded\u003Cstring\u003E(\r\n            new BoundedChannelOptions(capacity)\r\n            {\r\n                SingleWriter = true,\r\n                SingleReader = _maxDegreeOfParallelism == 1,\r\n                FullMode = BoundedChannelFullMode.Wait,\r\n            }\r\n        );\r\n\r\n        var producerTask = Produce();\r\n\r\n        var consumerTasks = Enumerable\r\n            .Range(0, _maxDegreeOfParallelism)\r\n            .Select(_ =\u003E Consume())\r\n            .ToArray();\r\n\r\n        try\r\n        {\r\n            await Task.WhenAll(consumerTasks.Prepend(producerTask));\r\n        }\r\n        catch\r\n        {\r\n            cts.Cancel();\r\n            channel.Writer.TryComplete();\r\n            throw;\r\n        }\r\n\r\n        async Task Produce()\r\n        {\r\n            try\r\n            {\r\n                foreach (var filePath in fileEnumerator)\r\n                {\r\n                    await channel.Writer.WriteAsync(filePath, cancellationToken);\r\n                }\r\n            }\r\n            catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)\r\n            {\r\n                // ignore\r\n            }\r\n            finally\r\n            {\r\n                channel.Writer.TryComplete();\r\n            }\r\n        }\r\n\r\n        async Task Consume()\r\n        {\r\n            try\r\n            {\r\n                while (await channel.Reader.WaitToReadAsync(cancellationToken))\r\n                {\r\n                    while (channel.Reader.TryRead(out var filePath))\r\n                    {\r\n                        await InternalSearchInZipAsync(filePath, cancellationToken);\r\n                    }\r\n                }\r\n            }\r\n            catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)\r\n            {\r\n                // ignore\r\n            }\r\n        }\r\n\r\n        async Task InternalSearchInZipAsync(string filePath, CancellationToken cancellationToken)\r\n        {\r\n            var enumerator = ZipFileSearcher.SearchInZipAsync(\r\n                filePath,\r\n                lineMatcher,\r\n                fileMatcher,\r\n                options,\r\n                cancellationToken: cancellationToken\r\n            );\r\n\r\n            await foreach (\r\n                var item in enumerator.ConfigureAwait(false).WithCancellation(cancellationToken)\r\n            )\r\n            {\r\n                Console.WriteLine(item);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.ConsoleApp\\DIRegistrations.cs",
    "content": "using Microsoft.Extensions.DependencyInjection;\r\nusing Vaerktojer.Logging.File;\r\nusing Vaerktojer.LogSearch.Lib;\r\n\r\nnamespace Vaerktojer.LogSearch.ConsoleApp;\r\n\r\npublic static class DIRegistrations\r\n{\r\n    private static readonly string appBasePath = Path.Combine(\r\n        Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),\r\n        \u0022Vaerktojer.LogSearch.ConsoleApp\u0022\r\n    );\r\n\r\n    public static IServiceCollection AddLogSearchConsoleApp(this IServiceCollection services)\r\n    {\r\n        services.AddLogSearchLib();\r\n\r\n        services.AddVaerktojerFileLogging(\r\n            Path.Combine(appBasePath, \u0022Logs\u0022),\r\n            enableConsoleLogging: false\r\n#if DEBUG\r\n            ,\r\n            minimumLogLevel: Microsoft.Extensions.Logging.LogLevel.Trace\r\n#endif\r\n        );\r\n\r\n        services.AddSingleton\u003CApp\u003E();\r\n\r\n        return services;\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.ConsoleApp\\FormChain.cs",
    "content": "namespace Vaerktojer.LogSearch.ConsoleApp;\r\n\r\ninternal class FormChain : INavigateable\r\n{\r\n    public required INavigateable chainData;\r\n    public virtual List\u003CIChainStep\u003E Steps { get; }\r\n\r\n    private int currentIndex = 0;\r\n    private bool isComplete = false;\r\n\r\n    public void Process()\r\n    {\r\n        if (isComplete)\r\n        {\r\n            throw new Exception(\u0022Is already complete\u0022);\r\n        }\r\n\r\n        while (currentIndex \u003C chainData.Steps.Count)\r\n        {\r\n            try\r\n            {\r\n                chainData.Steps[currentIndex].Invoke();\r\n                currentIndex\u002B\u002B;\r\n            }\r\n            catch (MovePreviousException)\r\n            {\r\n                if (currentIndex \u003E 0)\r\n                {\r\n                    currentIndex--;\r\n                }\r\n            }\r\n        }\r\n\r\n        isComplete = true;\r\n    }\r\n}\r\n\r\npublic class MovePreviousException() : Exception(\u0022\u0022);\r\n\r\npublic interface IChainStep\r\n{\r\n    void Invoke();\r\n}\r\n\r\npublic class ChainStep : IChainStep\r\n{\r\n    private readonly Action _action;\r\n\r\n    public ChainStep(Action action)\r\n    {\r\n        _action = action;\r\n    }\r\n\r\n    public void Invoke()\r\n    {\r\n        _action.Invoke();\r\n    }\r\n\r\n    public static ChainStep ToChainStep(Action action)\r\n    {\r\n        return new ChainStep(action);\r\n    }\r\n}\r\n\r\npublic interface INavigateable\r\n{\r\n    List\u003CIChainStep\u003E Steps { get; }\r\n}\r\n\r\npublic class ChainData : INavigateable\r\n{\r\n    public List\u003CIChainStep\u003E Steps { get; }\r\n    private string _username = null!;\r\n    private string _password = null!;\r\n    private List\u003Cstring\u003E _servers = null!;\r\n    private string _application = null!;\r\n\r\n    public ChainData()\r\n    {\r\n        //Steps = [ChainStep.ToChainStep(GetCredentialsStep), GetApplicationStep, GetServersStep];\r\n    }\r\n\r\n    private void GetUsername()\r\n    {\r\n        _username = Prompt.Prompt.Input\u003Cstring\u003E(\u0022Username\u0022);\r\n    }\r\n\r\n    private void GetPassword()\r\n    {\r\n        _password = Prompt.Prompt.Password(\u0022Password\u0022);\r\n    }\r\n\r\n    private void GetCredentialsStep()\r\n    {\r\n        GetUsername();\r\n        GetPassword();\r\n        ValidateLogin().GetAwaiter().GetResult();\r\n    }\r\n\r\n    private async Task ValidateLogin()\r\n    {\r\n        Console.WriteLine(_username);\r\n        Console.WriteLine(_password);\r\n        await Task.Delay(10);\r\n    }\r\n\r\n    private void GetApplicationStep()\r\n    {\r\n        GetApplication();\r\n    }\r\n\r\n    private void GetServersStep()\r\n    {\r\n        GetServers();\r\n    }\r\n\r\n    private void GetApplication()\r\n    {\r\n        _application = Prompt.Prompt.Select(\u0022Select application\u0022, [\u0022\u0022]);\r\n    }\r\n\r\n    private void GetServers()\r\n    {\r\n        _servers = Prompt.Prompt.MultiSelect(\u0022Select servers\u0022, [\u0022123\u0022, \u00221234\u0022]).ToList();\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.ConsoleApp\\Program.cs",
    "content": "using Microsoft.Extensions.DependencyInjection;\r\nusing Vaerktojer.LogSearch.ConsoleApp;\r\n\r\nstatic async Task Demo()\r\n{\r\n    Console.WriteLine(Console.BufferWidth);\r\n\r\n    //Console.BufferWidth \u002B= 50;\r\n    Console.WindowWidth \u002B= 100;\r\n    Console.WriteLine(\u0022wowzerz\u0022);\r\n\r\n    while (true)\r\n    {\r\n        await Task.Delay(1000);\r\n        Console.SetBufferSize(3, 5);\r\n        Console.WriteLine($\u0022{Console.BufferWidth}, {Console.BufferHeight}\u0022);\r\n        Console.WindowWidth \u002B= 5;\r\n        //var key = Console.ReadLine();\r\n        //Console.SetCursorPosition(int.Parse(key.Split(\u0027,\u0027)[0]), int.Parse(key.Split(\u0027,\u0027)[1]));\r\n    }\r\n}\r\n\r\nvar app = new ServiceCollection()\r\n    .AddLogSearchConsoleApp()\r\n    .BuildServiceProvider(validateScopes: true)\r\n    .GetRequiredService\u003CApp\u003E();\r\n\r\nawait app.Run();\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.ConsoleApp\\Vaerktojer.LogSearch.ConsoleApp.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CPublishAot\u003Etrue\u003C/PublishAot\u003E\r\n    \u003CInvariantGlobalization\u003Etrue\u003C/InvariantGlobalization\u003E\r\n    \u003CUseLocalProjectReferences\u003Etrue\u003C/UseLocalProjectReferences\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.DependencyInjection\u0022 Version=\u00229.0.8\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022ZLogger\u0022 Version=\u00222.5.10\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup Condition=\u0022$(UseLocalProjectReferences) != true\u0022\u003E\r\n    \u003CPackageReference Include=\u0022Vaerktojer.Prompt\u0022 Version=\u00220.0.1\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup Condition=\u0022$(UseLocalProjectReferences) == true\u0022\u003E\r\n    \u003CProjectReference Include=\u0022..\\..\\Vaerktojer.Prompt\\Vaerktojer.Prompt\\Vaerktojer.Prompt.csproj\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CProjectReference Include=\u0022..\\Vaerktojer.Logging.File\\Vaerktojer.Logging.File.csproj\u0022 /\u003E\r\n    \u003CProjectReference Include=\u0022..\\Vaerktojer.LogSearch.Lib\\Vaerktojer.LogSearch.Lib.csproj\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Benchmarks\\LogFileSearchBenchmark.cs",
    "content": "using System.Threading.Channels;\r\nusing BenchmarkDotNet.Attributes;\r\nusing Vaerktojer.LogSearch.Lib.Core;\r\nusing Vaerktojer.LogSearch.Lib.Data;\r\nusing Vaerktojer.LogSearch.Lib.Filters;\r\nusing Vaerktojer.LogSearch.Lib.Matchers;\r\n\r\nnamespace Vaerktojer.LogSearch.Benchmarks;\r\n\r\n[MemoryDiagnoser]\r\n[SimpleJob]\r\npublic class LogFileSearchBenchmark\r\n{\r\n    private const string _basePath = @\u0022D:\\Temporary\\zipdemo\\logfiles\u0022;\r\n    private const string _searchPattern = \u0022f47de3ba-c88c-6c50-cae7-4b72b2e9346b\u0022;\r\n    private readonly DateTimeOffset _startTime = DateTimeOffset.Now.Subtract(\r\n        TimeSpan.FromDays(365)\r\n    );\r\n    private readonly DateTimeOffset _endTime = DateTimeOffset.Now;\r\n    private const int _maxDegreeOfParallelism = 16;\r\n\r\n    [Benchmark]\r\n    public async Task Bench_Search_For_Pattern_In_Log_Files_In_Directory_By_Chunking_Async()\r\n    {\r\n        using var cts = new CancellationTokenSource();\r\n\r\n        var cancellationToken = cts.Token;\r\n\r\n        var fileEnumerator = FileEnumerator.EnumerateFiles(\r\n            _basePath,\r\n            new LogFileEnumerationFilter(_startTime, _endTime),\r\n            cancellationToken: cancellationToken\r\n        );\r\n\r\n        var options = new FileSearchOptions(StopWhenFound: false);\r\n        var lineMatcher = new StringContainsLineMatcher(_searchPattern);\r\n\r\n        foreach (var chunks in fileEnumerator.Chunk(_maxDegreeOfParallelism))\r\n        {\r\n            await Task.WhenAll(chunks.Select(InternalSearch));\r\n        }\r\n\r\n        async Task InternalSearch(string filePath)\r\n        {\r\n            try\r\n            {\r\n                var enumerator = FileSearcher.SearchInFileAsync(\r\n                    filePath,\r\n                    lineMatcher,\r\n                    options,\r\n                    cancellationToken: cancellationToken\r\n                );\r\n\r\n                await foreach (\r\n                    var item in enumerator.ConfigureAwait(false).WithCancellation(cancellationToken)\r\n                )\r\n                {\r\n                    //Console.WriteLine(item);\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex);\r\n            }\r\n        }\r\n    }\r\n\r\n    [Benchmark]\r\n    public async Task Bench_Search_For_Pattern_In_Log_Files_In_Directory_With_Channels()\r\n    {\r\n        using var cts = new CancellationTokenSource();\r\n        var cancellationToken = cts.Token;\r\n\r\n        var fileEnumerator = FileEnumerator.EnumerateFiles(\r\n            _basePath,\r\n            new LogFileEnumerationFilter(_startTime, _endTime),\r\n            cancellationToken: cancellationToken\r\n        );\r\n\r\n        var options = new FileSearchOptions(StopWhenFound: false);\r\n        var lineMatcher = new StringContainsLineMatcher(_searchPattern);\r\n\r\n        var capacity = Math.Max(_maxDegreeOfParallelism * 2, 1);\r\n        var channel = Channel.CreateBounded\u003Cstring\u003E(\r\n            new BoundedChannelOptions(capacity)\r\n            {\r\n                SingleWriter = true,\r\n                SingleReader = _maxDegreeOfParallelism == 1,\r\n                FullMode = BoundedChannelFullMode.Wait,\r\n            }\r\n        );\r\n\r\n        var producerTask = Produce();\r\n\r\n        var consumerTasks = Enumerable\r\n            .Range(0, _maxDegreeOfParallelism)\r\n            .Select(_ =\u003E Consume())\r\n            .ToArray();\r\n\r\n        try\r\n        {\r\n            await Task.WhenAll(consumerTasks.Prepend(producerTask));\r\n        }\r\n        catch\r\n        {\r\n            cts.Cancel();\r\n            channel.Writer.TryComplete();\r\n            throw;\r\n        }\r\n\r\n        async Task Produce()\r\n        {\r\n            try\r\n            {\r\n                foreach (var filePath in fileEnumerator)\r\n                {\r\n                    await channel.Writer.WriteAsync(filePath, cancellationToken);\r\n                }\r\n            }\r\n            catch (OperationCanceledException) { }\r\n            finally\r\n            {\r\n                channel.Writer.TryComplete();\r\n            }\r\n        }\r\n\r\n        async Task Consume()\r\n        {\r\n            try\r\n            {\r\n                while (await channel.Reader.WaitToReadAsync(cancellationToken))\r\n                {\r\n                    while (channel.Reader.TryRead(out var filePath))\r\n                    {\r\n                        await InternalSearch(filePath, cancellationToken);\r\n                    }\r\n                }\r\n            }\r\n            catch (OperationCanceledException) { }\r\n        }\r\n\r\n        async Task InternalSearch(string filePath, CancellationToken cancellationToken)\r\n        {\r\n            var enumerator = FileSearcher.SearchInFileAsync(\r\n                filePath,\r\n                lineMatcher,\r\n                options,\r\n                cancellationToken: cancellationToken\r\n            );\r\n\r\n            await foreach (\r\n                var item in enumerator.ConfigureAwait(false).WithCancellation(cancellationToken)\r\n            )\r\n            {\r\n                //Console.WriteLine(item);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Benchmarks\\Program.cs",
    "content": "using System.Diagnostics;\r\nusing BenchmarkDotNet.Running;\r\nusing Vaerktojer.LogSearch.Benchmarks;\r\n\r\nBench();\r\nEnvironment.Exit(0);\r\nawait Demo();\r\n\r\nstatic async Task Demo()\r\n{\r\n    var sw = Stopwatch.StartNew();\r\n\r\n    await new LogFileSearchBenchmark().Bench_Search_For_Pattern_In_Log_Files_In_Directory_By_Chunking_Async();\r\n    await new LogFileSearchBenchmark().Bench_Search_For_Pattern_In_Log_Files_In_Directory_With_Channels();\r\n\r\n    //await new ZipSearchBenchmark().Bench_Search_For_Pattern_In_Log_Files_In_Directory_With_Channels();\r\n\r\n    Console.WriteLine($\u0022Run took {sw.Elapsed.TotalSeconds} seconds.\u0022);\r\n\r\n    sw.Restart();\r\n\r\n    //await new ZipSearchBenchmark().Bench_Search_For_Pattern_In_Log_Files_In_Directory_With_Channels();\r\n\r\n    //Console.WriteLine($\u0022Run took {sw.Elapsed.TotalSeconds} seconds.\u0022);\r\n}\r\n\r\nstatic void Bench()\r\n{\r\n    //BenchmarkRunner.Run\u003CZipSearchBenchmark\u003E();\r\n    BenchmarkRunner.Run\u003CLogFileSearchBenchmark\u003E();\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Benchmarks\\Vaerktojer.LogSearch.Benchmarks.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CIsAotCompatible\u003Etrue\u003C/IsAotCompatible\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference\r\n      Include=\u0022Microsoft.Extensions.DependencyInjection.Abstractions\u0022\r\n      Version=\u00229.0.8\u0022\r\n    /\u003E\r\n    \u003CPackageReference Include=\u0022BenchmarkDotNet\u0022 Version=\u00220.15.2\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CProjectReference Include=\u0022..\\Vaerktojer.LogSearch.Lib\\Vaerktojer.LogSearch.Lib.csproj\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Benchmarks\\ZipSearchBenchmark.cs",
    "content": "using System.Threading.Channels;\r\nusing BenchmarkDotNet.Attributes;\r\nusing Vaerktojer.LogSearch.Lib.Core;\r\nusing Vaerktojer.LogSearch.Lib.Data;\r\nusing Vaerktojer.LogSearch.Lib.Filters;\r\nusing Vaerktojer.LogSearch.Lib.Matchers;\r\n\r\nnamespace Vaerktojer.LogSearch.Benchmarks;\r\n\r\n[MemoryDiagnoser]\r\n[SimpleJob]\r\npublic class ZipSearchBenchmark\r\n{\r\n    private const string _basePath = @\u0022D:\\Temporary\\zipdemo\\multi\u0022;\r\n    private const string _searchPattern = \u0022f47de3ba-c88c-6c50-cae7-4b72b2e9346b\u0022;\r\n    private readonly DateTimeOffset _startTime = DateTimeOffset.Now;\r\n    private readonly DateTimeOffset _endTime = DateTimeOffset.Now;\r\n    private const int _maxDegreeOfParallelism = 4;\r\n\r\n    [Benchmark(Baseline = true)]\r\n    public void Bench_Search_For_Pattern_In_Zip_Files_In_Directory_Sequential()\r\n    {\r\n        using var cts = new CancellationTokenSource();\r\n\r\n        var cancellationToken = cts.Token;\r\n\r\n        var fileEnumerator = FileEnumerator.EnumerateFiles(\r\n            _basePath,\r\n            new ZipFileEnumerationFilter(),\r\n            cancellationToken: cancellationToken\r\n        );\r\n\r\n        var options = new ZipFileSearchOptions(StopWhenFound: false);\r\n        var lineMatcher = new StringContainsLineMatcher(_searchPattern);\r\n        var zipArchiveEntryFilter = new ZipArchiveEntryFilter(_endTime);\r\n\r\n        foreach (var filePath in fileEnumerator)\r\n        {\r\n            var enumerator = ZipFileSearcher.SearchInZip(\r\n                filePath,\r\n                lineMatcher,\r\n                zipArchiveEntryFilter,\r\n                options,\r\n                cancellationToken: cancellationToken\r\n            );\r\n\r\n            foreach (var item in enumerator)\r\n            {\r\n                //Console.WriteLine(item);\r\n            }\r\n        }\r\n    }\r\n\r\n    [Benchmark]\r\n    public async Task Bench_Search_For_Pattern_In_Zip_Files_In_Directory_By_Chunking_Async()\r\n    {\r\n        using var cts = new CancellationTokenSource();\r\n\r\n        var cancellationToken = cts.Token;\r\n\r\n        var fileEnumerator = FileEnumerator.EnumerateFiles(\r\n            _basePath,\r\n            new ZipFileEnumerationFilter(),\r\n            cancellationToken: cancellationToken\r\n        );\r\n\r\n        var options = new ZipFileSearchOptions(StopWhenFound: false);\r\n        var lineMatcher = new StringContainsLineMatcher(_searchPattern);\r\n        var fileMatcher = new ZipArchiveEntryFilter(_endTime);\r\n\r\n        foreach (var chunks in fileEnumerator.Chunk(_maxDegreeOfParallelism))\r\n        {\r\n            await Task.WhenAll(chunks.Select(InternalSearchInZipAsync));\r\n        }\r\n\r\n        async Task InternalSearchInZipAsync(string filePath)\r\n        {\r\n            var enumerator = ZipFileSearcher.SearchInZipAsync(\r\n                filePath,\r\n                lineMatcher,\r\n                fileMatcher,\r\n                options,\r\n                cancellationToken: cancellationToken\r\n            );\r\n\r\n            await foreach (var item in enumerator)\r\n            {\r\n                //Console.WriteLine(item);\r\n            }\r\n        }\r\n    }\r\n\r\n    [Benchmark]\r\n    public async Task Bench_Search_For_Pattern_In_Log_Files_In_Directory_With_Channels()\r\n    {\r\n        using var cts = new CancellationTokenSource();\r\n        var cancellationToken = cts.Token;\r\n\r\n        var fileEnumerator = FileEnumerator.EnumerateFiles(\r\n            _basePath,\r\n            new ZipFileEnumerationFilter(),\r\n            cancellationToken: cancellationToken\r\n        );\r\n\r\n        var options = new ZipFileSearchOptions(StopWhenFound: false);\r\n        var lineMatcher = new StringContainsLineMatcher(_searchPattern);\r\n        var fileMatcher = new ZipArchiveEntryFilter(_endTime);\r\n\r\n        var capacity = Math.Max(_maxDegreeOfParallelism * 2, 1);\r\n        var channel = Channel.CreateBounded\u003Cstring\u003E(\r\n            new BoundedChannelOptions(capacity)\r\n            {\r\n                SingleWriter = true,\r\n                SingleReader = _maxDegreeOfParallelism == 1,\r\n                FullMode = BoundedChannelFullMode.Wait,\r\n            }\r\n        );\r\n\r\n        var producerTask = Produce();\r\n\r\n        var consumerTasks = Enumerable\r\n            .Range(0, _maxDegreeOfParallelism)\r\n            .Select(_ =\u003E Consume())\r\n            .ToArray();\r\n\r\n        try\r\n        {\r\n            await Task.WhenAll(consumerTasks.Prepend(producerTask));\r\n        }\r\n        catch\r\n        {\r\n            cts.Cancel();\r\n            channel.Writer.TryComplete();\r\n            throw;\r\n        }\r\n\r\n        async Task Produce()\r\n        {\r\n            try\r\n            {\r\n                foreach (var filePath in fileEnumerator)\r\n                {\r\n                    await channel.Writer.WriteAsync(filePath, cancellationToken);\r\n                }\r\n            }\r\n            catch (OperationCanceledException) { }\r\n            finally\r\n            {\r\n                channel.Writer.TryComplete();\r\n            }\r\n        }\r\n\r\n        async Task Consume()\r\n        {\r\n            try\r\n            {\r\n                while (await channel.Reader.WaitToReadAsync(cancellationToken))\r\n                {\r\n                    while (channel.Reader.TryRead(out var filePath))\r\n                    {\r\n                        await InternalSearchInZipAsync(filePath, cancellationToken);\r\n                    }\r\n                }\r\n            }\r\n            catch (OperationCanceledException) { }\r\n        }\r\n\r\n        async Task InternalSearchInZipAsync(string filePath, CancellationToken cancellationToken)\r\n        {\r\n            var enumerator = ZipFileSearcher.SearchInZipAsync(\r\n                filePath,\r\n                lineMatcher,\r\n                fileMatcher,\r\n                options,\r\n                cancellationToken: cancellationToken\r\n            );\r\n\r\n            await foreach (\r\n                var item in enumerator.ConfigureAwait(false).WithCancellation(cancellationToken)\r\n            )\r\n            {\r\n                //Console.WriteLine(item);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Abstractions\\IFileSystemEnumerationFilter.cs",
    "content": "using System.IO.Enumeration;\r\n\r\nnamespace Vaerktojer.LogSearch.Abstractions;\r\n\r\npublic interface IFileSystemEnumerationFilter\r\n{\r\n    bool IncludeFile(ref FileSystemEntry entry);\r\n    bool ExcludeDirectory(ref FileSystemEntry entry);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Abstractions\\ILineMatcher.cs",
    "content": "namespace Vaerktojer.LogSearch.Abstractions;\r\n\r\npublic interface ILineMatcher\r\n{\r\n    bool IsMatch(string line);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Abstractions\\IZipArchiveEntryFilter.cs",
    "content": "using System.IO.Compression;\r\n\r\nnamespace Vaerktojer.LogSearch.Abstractions;\r\n\r\npublic interface IZipArchiveEntryFilter\r\n{\r\n    bool Include(ZipArchiveEntry entry);\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.LogSearch.Abstractions\\Vaerktojer.LogSearch.Abstractions.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003ELibrary\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet8.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CIsAotCompatible\u003Etrue\u003C/IsAotCompatible\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference\r\n      Include=\u0022Microsoft.Extensions.DependencyInjection.Abstractions\u0022\r\n      Version=\u00229.0.8\u0022\r\n    /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Vaerktojer.Logging.File\\DIRegistrations.cs",
    "content": "using Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Logging;\r\nusing ZLogger;\r\nusing ZLogger.Formatters;\r\n\r\nnamespace Vaerktojer.Logging.File;\r\n\r\npublic static class DIRegistrations\r\n{\r\n    public static IServiceCollection AddVaerktojerFileLogging(\r\n        this IServiceCollection services,\r\n        string basePath,\r\n        LogLevel minimumLogLevel = LogLevel.Information,\r\n        bool enableConsoleLogging = false,\r\n        int rollingSizeKB = 1024 * 1024\r\n    )\r\n    {\r\n        services.AddLogging(x =\u003E\r\n        {\r\n            x.ClearProviders();\r\n\r\n            x.SetMinimumLevel(minimumLogLevel);\r\n\r\n            if (enableConsoleLogging)\r\n            {\r\n                x.AddZLoggerConsole(options =\u003E\r\n                {\r\n                    options.UsePlainTextFormatter(ConfigureFormatter);\r\n                    options.OutputEncodingToUtf8 = true;\r\n                    options.LogToStandardErrorThreshold = LogLevel.Warning;\r\n                });\r\n            }\r\n\r\n            x.AddZLoggerRollingFile(options =\u003E\r\n            {\r\n                options.UsePlainTextFormatter(ConfigureFormatter);\r\n                options.RollingInterval = ZLogger.Providers.RollingInterval.Day;\r\n                options.FilePathSelector = (utcDt, fileNumber) =\u003E\r\n                {\r\n                    var localDt = utcDt.ToLocalTime();\r\n                    return Path.Combine(\r\n                        basePath,\r\n                        $\u0022{localDt:yyyy-MM-dd}\u0022,\r\n                        $\u0022{localDt:yyyy-MM-dd}_{fileNumber}.log\u0022\r\n                    );\r\n                };\r\n                options.RollingSizeKB = rollingSizeKB;\r\n            });\r\n\r\n            static void ConfigureFormatter(PlainTextZLoggerFormatter formatter)\r\n            {\r\n                formatter.SetPrefixFormatter(\r\n                    $\u0022[{0:local-longdate}] [{1}] [{2}] \u0022,\r\n                    (in MessageTemplate template, in LogInfo logInfo) =\u003E\r\n                        template.Format(logInfo.Timestamp, logInfo.LogLevel, logInfo.Category)\r\n                );\r\n            }\r\n        });\r\n\r\n        return services;\r\n    }\r\n}\r\n"
  },
  {
    "path": "Vaerktojer.Logging.File\\Vaerktojer.Logging.File.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CTargetFramework\u003Enet8.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022ZLogger\u0022 Version=\u00222.5.10\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  }
]